# https://www.acmicpc.net/problem/2167
N, M = map(int, input().split())
A = [list(map(int, input().split())) for _ in range(N)]
K = int(input())
Q = [list(map(int, input().split())) for _ in range(K)]
# Q[i] = [i, j, x, y]

"""
누적합

구간합을 구할 때 누적합을 사용하지 않으면 계산할 때마다 O(N^2)의 시간복잡도가 필요하다.

누적합은 O(N)으로 구할 수 있는데 이를 미리 계산해둔다면 구간합은 O(1)로 구할 수 있다.

A = [0, 1, 2, 3, 4, 5]
DP = [0, 1, 3, 6, 10, 15]

DP[i] = i번째까지의 누적합 = DP[i] + DP[i-1]

A[3]부터 A[5]까지의 구간합: DP[5] - DP[3-1] = 12 (O(N))

== == == == == == == == == == == == == == == == == == == == == == == ==

2차원 배열 누적합

2차원 배열에서의 누적합은 O(N^2)으로 구할 수 있다.

A = [
    [1, 2, 3, 4, 5],
    [6, 7, 8, 9, 10]
]
DP = [
    [0, 0, 0, 0, 0, 0]  # 계산을 편하게 하기 위해 추가한다.
    [0, 1, 3, 6, 10, 15],
    [0, 7, 16, 27, 40, 55]
]

DP[i][j] = (1, 1)부터 (i, j)까지의 누적합 = A[i-1][j-1] + DP[i-1][j] + DP[i][j-1] - DP[i-1][j-1]

> DP[i-1][j-1] 부분은 DP[i-1][j], DP[i][j-1]에서 누적합을 구할 때 중복되었으므로 하나 빼준다.

A(i, j)부터 A(x, y)까지의 구간합

(1,1)-----------(i,1)-----------(x,1)
  |               |               |
  |       1       |       2       |
  |               |               |
(1,j)-----------(i,j)-----------(x,j)
  |               |               |
  |       3       |       4       |
  |               |               |
(1,y)-----------(i,y)-----------(x,y)

ANSWER = DP(x,y) - DP(x,j-1) - DP(i-1,y) + DP(i-1,j-1)
       => (1+2+3+4) - (1+2) - (1+3) + 1 (1을 중복으로 뺐으므로 한 번 더해줘야 한다.)
"""

# 계산을 간편하게 하기 위해 IndexError가 날 수 있는 부분을 0으로 패딩 처리한다.
DP = [[0 for _ in range(M + 1)] for _ in range(N + 1)]

for i in range(1, N + 1):
    for j in range(1, M + 1):  # 패딩을 넣었으므로 A[i][j]이 아니라 A[i-1][j-1]으로 한다.
        DP[i][j] = A[i - 1][j - 1] + DP[i - 1][j] + \
            DP[i][j - 1] - DP[i - 1][j - 1]

for i, j, x, y in Q:
    print(DP[x][y] - DP[x][j - 1] - DP[i - 1][y] + DP[i - 1][j - 1])
