"""
연인 코니와 브라운은 광활한 들판에서 ‘나 잡아 봐라’ 게임을 한다. 이 게임은 브라운이 코니를 잡거나, 코니가 너무 멀리 달아나면 끝난다. 게임이 끝나는데 걸리는 최소 시간을 구하시오.

조건
 - 코니는 처음 위치 C에서 1초 후 1만큼 움직이고, 이후에는 가속이 붙어 매 초마다 이전 이동 거리 + 1만큼 움직인다.
   즉 시간에 따른 코니의 위치는 C, C + 1, C + 3, C + 6, …이다.
 - 브라운은 현재 위치 B에서 다음 순간 B – 1, B + 1, 2 * B 중 하나로 움직일 수 있다.
 - 코니와 브라운의 위치 p => 0 <= x <= 200,000을 만족한다.
 - 브라운은 범위를 벗어나는 위치로는 이동할 수 없고, 코니가 범위를 벗어나면 게임이 끝난다.

출력 형식
 - 브라운이 코니를 잡을 수 있는 최소시간 N초를 표준 출력한다. 단 브라운이 코니를 잡지 못한 경우에는 -1을 출력한다.
예제 입력

C   B    출력
11  2    5

예제 설명
 - 코니의 위치: 11 → 12 → 14 → 17 → 21 → 26
 - 브라운의 위치: 2 → 3 → 6 → 12 → 13 → 26
 - 브라운은 코니를 5초 만에 잡을 수 있다.
"""

from collections import deque


def solution(C, B):
    """
    최소 거리를 탐색해야 하므로 bfs를 이용한다.

    코니는 이전 이동 거리에서 1만큼 증가하므로 이전 이동 거리를 저장한다.
    브라운은 (B-1, B+1, B*2) 거리를 이동하므로 모든 경우를 고려하여 가장 먼저 코니를 잡은 시간을 반환하고 그 외에 -1을 반환한다.

    C: 코니의 시작 위치, B: 브라운의 현재 위치
    c: 코니의 현재 위치, t: 시간, p_c: 코니의 이전 이동거리

    0th     C, B
    1st     C+1, B-1 | C+1, B+1 | C+1, 2*B
    2nd     (C+p_c-C+1)(B-1, B+1, 2*B)
    ...
    """

    queue = deque()
    queue.append((0, 0, C, B))

    def in_field(p):
        return p >= 0 and p <= 200000

    while queue:
        t, p_c, c, b = queue.popleft()
        if c == b:
            return t

        p_c = p_c + 1
        t, c = t + 1, c + p_c
        if not in_field(c):
            continue

        queue.extend([
            (t, p_c, c, d)
            for d in [b - 1, b + 1, 2 * b]
            if in_field(d)
        ])

    return -1


C, B = 11, 2
print(solution(C, B))
